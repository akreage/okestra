
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>activity: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/acreage/okestra/activity/activity_graph.go (100.0%)</option>
				
				<option value="file1">github.com/acreage/okestra/activity/activity_stage.go (92.7%)</option>
				
				<option value="file2">github.com/acreage/okestra/activity/interface.go (0.0%)</option>
				
				<option value="file3">github.com/acreage/okestra/activity/task.go (100.0%)</option>
				
				<option value="file4">github.com/acreage/okestra/activity/task_definition.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package activity

import (
        "errors"
        "fmt"
)

// activity graph struct
type ActivityGraph struct {
        Nodes []string
        Edges map[string][]string
}

// NewActivityGraph creates a new activity graph
func NewActivityGraph() *ActivityGraph <span class="cov8" title="1">{
        return &amp;ActivityGraph{
                Nodes: []string{},
                Edges: make(map[string][]string),
        }
}</span>

// AddNode adds a node to the graph
func (g *ActivityGraph) AddNode(taskId string) error <span class="cov8" title="1">{
        // Check if node already exists
        for _, node := range g.Nodes </span><span class="cov8" title="1">{
                if node == taskId </span><span class="cov8" title="1">{
                        return &amp;ActivityError{
                                Op:  "AddNode",
                                Err: errors.New("node already exists"),
                                Key: taskId,
                        }
                }</span>
        }

        <span class="cov8" title="1">g.Nodes = append(g.Nodes, taskId)
        g.Edges[taskId] = []string{}
        return nil</span>
}

// AddEdge adds an edge between two nodes
func (g *ActivityGraph) AddEdge(fromTaskId string, toTaskId string) error <span class="cov8" title="1">{
        // Check if both nodes exist
        fromExists := false
        toExists := false

        for _, node := range g.Nodes </span><span class="cov8" title="1">{
                if node == fromTaskId </span><span class="cov8" title="1">{
                        fromExists = true
                }</span>
                <span class="cov8" title="1">if node == toTaskId </span><span class="cov8" title="1">{
                        toExists = true
                }</span>
                <span class="cov8" title="1">if fromExists &amp;&amp; toExists </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">if !fromExists </span><span class="cov8" title="1">{
                return &amp;ActivityError{
                        Op:  "AddEdge",
                        Err: fmt.Errorf("source node %s does not exist", fromTaskId),
                        Key: fromTaskId,
                }
        }</span>

        <span class="cov8" title="1">if !toExists </span><span class="cov8" title="1">{
                return &amp;ActivityError{
                        Op:  "AddEdge",
                        Err: fmt.Errorf("destination node %s does not exist", toTaskId),
                        Key: toTaskId,
                }
        }</span>

        // Check if adding this edge would create a cycle
        <span class="cov8" title="1">if g.wouldCreateCycle(fromTaskId, toTaskId) </span><span class="cov8" title="1">{
                return &amp;ActivityError{
                        Op:  "AddEdge",
                        Err: errors.New("adding this edge would create a cycle"),
                        Key: fromTaskId + "-&gt;" + toTaskId,
                }
        }</span>

        // Add the edge
        <span class="cov8" title="1">g.Edges[fromTaskId] = append(g.Edges[fromTaskId], toTaskId)
        return nil</span>
}

// HasCycle checks if the graph has a cycle
func (g *ActivityGraph) HasCycle() bool <span class="cov8" title="1">{
        visited := make(map[string]bool)
        recStack := make(map[string]bool)

        for _, nodeID := range g.Nodes </span><span class="cov8" title="1">{
                if !visited[nodeID] </span><span class="cov8" title="1">{
                        if g.hasCycleUtil(nodeID, visited, recStack) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }

        <span class="cov8" title="1">return false</span>
}

// hasCycleUtil is a helper function for cycle detection
func (g *ActivityGraph) hasCycleUtil(nodeID string, visited map[string]bool, recStack map[string]bool) bool <span class="cov8" title="1">{
        // Mark the current node as visited and add to recursion stack
        visited[nodeID] = true
        recStack[nodeID] = true

        // Visit all adjacent vertices
        for _, adjacentID := range g.Edges[nodeID] </span><span class="cov8" title="1">{
                // If not visited, recursively check for cycles
                if !visited[adjacentID] </span><span class="cov8" title="1">{
                        if g.hasCycleUtil(adjacentID, visited, recStack) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                } else<span class="cov8" title="1"> if recStack[adjacentID] </span><span class="cov8" title="1">{
                        // If the adjacent node is in the recursion stack, there's a cycle
                        return true
                }</span>
        }

        // Remove the node from recursion stack
        <span class="cov8" title="1">recStack[nodeID] = false
        return false</span>
}

// wouldCreateCycle checks if adding an edge would create a cycle
func (g *ActivityGraph) wouldCreateCycle(fromTaskId string, toTaskId string) bool <span class="cov8" title="1">{
        // Check if there's a path from toTaskId to fromTaskId
        // If there is, adding an edge from fromTaskId to toTaskId would create a cycle
        return g.isReachable(toTaskId, fromTaskId)
}</span>

// isReachable checks if there's a path from source to destination
func (g *ActivityGraph) isReachable(source string, destination string) bool <span class="cov8" title="1">{
        // Use BFS to check if destination is reachable from source
        visited := make(map[string]bool)
        queue := []string{source}

        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                current := queue[0]
                queue = queue[1:]

                if current == destination </span><span class="cov8" title="1">{
                        return true
                }</span>

                <span class="cov8" title="1">visited[current] = true

                for _, adjacent := range g.Edges[current] </span><span class="cov8" title="1">{
                        if !visited[adjacent] </span><span class="cov8" title="1">{
                                queue = append(queue, adjacent)
                        }</span>
                }
        }

        <span class="cov8" title="1">return false</span>
}

// TopologicalSort returns a topological ordering of the nodes
func (g *ActivityGraph) TopologicalSort() ([]string, error) <span class="cov8" title="1">{
        // Check for cycles first
        if g.HasCycle() </span><span class="cov8" title="1">{
                return nil, &amp;ActivityError{
                        Op:  "TopologicalSort",
                        Err: errors.New("cannot perform topological sort on a cyclic graph"),
                }
        }</span>

        // Perform topological sort
        <span class="cov8" title="1">visited := make(map[string]bool)
        var stack []string

        for _, nodeID := range g.Nodes </span><span class="cov8" title="1">{
                if !visited[nodeID] </span><span class="cov8" title="1">{
                        g.topologicalSortUtil(nodeID, visited, &amp;stack)
                }</span>
        }

        // Reverse the stack to get the topological sort
        <span class="cov8" title="1">result := make([]string, len(stack))
        for i, nodeID := range stack </span><span class="cov8" title="1">{
                result[len(stack)-1-i] = nodeID
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// topologicalSortUtil is a helper function for topological sort
func (g *ActivityGraph) topologicalSortUtil(nodeID string, visited map[string]bool, stack *[]string) <span class="cov8" title="1">{
        // Mark the current node as visited
        visited[nodeID] = true

        // Visit all adjacent vertices
        for _, adjacentID := range g.Edges[nodeID] </span><span class="cov8" title="1">{
                if !visited[adjacentID] </span><span class="cov8" title="1">{
                        g.topologicalSortUtil(adjacentID, visited, stack)
                }</span>
        }

        // Push current vertex to stack
        <span class="cov8" title="1">*stack = append(*stack, nodeID)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package activity

import (
        "context"
        "errors"
        "sync"

        "github.com/google/uuid"
)

// Data exchange hub.
// all tasks sends and receives data from this server.

type ActivityStageStatus string

const (
        ActivityStageStatusPending ActivityStageStatus = "pending"
        ActivityStageStatusHalted  ActivityStageStatus = "halted"
        ActivityStageStatusRunning ActivityStageStatus = "running"
        ActivityStageStatusDone    ActivityStageStatus = "done"
)

type ActivityStageStatusUpdateFunc func(status ActivityStageStatus)

// DataExchange is a struct that provides a way for task subscribers to request data.
// Data is cached in activity stage cache until a demand is made for the data.
// The ack is a number that is incremented for every new data processed.
type DataExchange struct {
        MinDemand int
        MaxDemand int
        Ready     bool
        Flush     bool
        TaskId    uuid.UUID
}

type CacheData struct {
        data []*TaskData
        ack  int
}

type ActivityStageInterface interface {
        // registers a task channel.
        // Each task returns a write channel to send data on,
        // and we send a read channel for them to receive data on.
        // Task channels are registered with a taskId
        RegisterTaskChannel(taskId uuid.UUID, taskChan chan&lt;- TaskData) (chan&lt;- TaskData, chan&lt;- DataExchange, error)
        // start an activity stage
        // the initial data is sent out via the channel
        Start()
        // init to initialize the services
        Init(initData []TaskData)
        // check if system is ready to receive requests
        IsReady() bool
        // close an activity stage
        Stop()
}

// TaskChannel implements the TaskChannelInterface
type ActivityStage struct {
        cache                    map[uuid.UUID]*CacheData      // holds the data for each task channel
        writeChan                chan TaskData                 // channel that all task writes will be sent on
        broadcastChan            map[uuid.UUID]chan&lt;- TaskData // array of channels to broadcast data to
        dataExchangeChan         chan DataExchange             // all requests for data by subscribers is sent on this channel
        taskAcks                 map[uuid.UUID]int             // holds the ack for each task
        pendingExchanges         []*DataExchange               // holds the pending exchange requests which are waiting to be fulfilled
        newDataChan              chan bool                     // alerts when new data is available.
        Graph                    *ActivityGraph
        wg                       sync.WaitGroup
        lock                     sync.RWMutex
        ctx                      context.Context
        cancel                   context.CancelFunc
        IncomingDataHandlerReady bool
        OutgoingDataHandlerReady bool
}

func NewActivityStage(graph *ActivityGraph) ActivityStageInterface <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(context.Background())
        activityStage := &amp;ActivityStage{
                cache:                    make(map[uuid.UUID]*CacheData),
                writeChan:                make(chan TaskData),
                broadcastChan:            make(map[uuid.UUID]chan&lt;- TaskData),
                dataExchangeChan:         make(chan DataExchange),
                taskAcks:                 make(map[uuid.UUID]int),
                newDataChan:              make(chan bool),
                Graph:                    graph,
                ctx:                      ctx,
                cancel:                   cancel,
                IncomingDataHandlerReady: false,
                OutgoingDataHandlerReady: false,
        }

        return activityStage
}</span>

func (as *ActivityStage) Start() <span class="cov8" title="1">{
        // create a goroutine to receive data from the receive chan
        // create a goroutine to receive data exchange requests
        as.handleIncomingData()
        as.handleDataExchangeRequests()
}</span>

func (as *ActivityStage) Init(initData []TaskData) <span class="cov8" title="1">{
        // get the first task
        taskId := as.getFirstTask()
        if taskId == uuid.Nil </span><span class="cov0" title="0">{
                // TODO: add error to telemetry
                err := ActivityError{
                        Op:  "addInitialData",
                        Err: errors.New("no initial task id found"),
                        Key: "no_task_id_found",
                }
                panic(err)</span>
        }

        <span class="cov8" title="1">if len(initData) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        // send the data to the task
        <span class="cov8" title="1">for _, data := range initData </span><span class="cov8" title="1">{
                as.addDataToCache(taskId, &amp;data)
        }</span>
        <span class="cov8" title="1">as.newDataChan &lt;- true</span>
}

func (as *ActivityStage) RegisterTaskChannel(taskId uuid.UUID, receiveChan chan&lt;- TaskData) (chan&lt;- TaskData, chan&lt;- DataExchange, error) <span class="cov8" title="1">{
        // register the task channel
        as.lock.Lock()
        defer as.lock.Unlock()

        as.broadcastChan[taskId] = receiveChan

        return as.writeChan, as.dataExchangeChan, nil
}</span>

func (as *ActivityStage) Stop() <span class="cov8" title="1">{
        as.cancel()
        close(as.dataExchangeChan)
        close(as.writeChan)

        as.wg.Wait()
}</span>

func (as *ActivityStage) IsReady() bool <span class="cov8" title="1">{
        return as.IncomingDataHandlerReady &amp;&amp; as.OutgoingDataHandlerReady
}</span>

func (as *ActivityStage) handleIncomingData() <span class="cov8" title="1">{
        as.wg.Add(1)

        go func() </span><span class="cov8" title="1">{
                defer as.wg.Done()

                // receive data on
                as.IncomingDataHandlerReady = true
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-as.ctx.Done():<span class="cov8" title="1">
                                return</span>
                        case data, ok := &lt;-as.writeChan:<span class="cov8" title="1">
                                if !ok </span><span class="cov0" title="0">{
                                        // TODO: add telemetry here
                                        return
                                }</span>

                                <span class="cov8" title="1">as.lock.Lock()
                                // identify the tasks that need to receive the data
                                // add the task data to thir cache
                                taskIds := as.listTasksThatDataShouldBeSentTo(data)
                                for _, taskId := range taskIds </span><span class="cov8" title="1">{
                                        as.addDataToCache(taskId, &amp;data)
                                }</span>
                                // maybe forward data to all pending taskIds
                                <span class="cov8" title="1">as.lock.Unlock()
                                as.newDataChan &lt;- true</span>
                                // TODO: add a way to alert the data exchanger to fetch the new data
                        }
                }
        }()
}

func (as *ActivityStage) addDataToCache(taskId uuid.UUID, data *TaskData) <span class="cov8" title="1">{
        dataCopy := *data
        // get the last data in the cache
        // update the ack number to its ack number + 1
        cacheData, exists := as.cache[taskId]
        if !exists </span><span class="cov8" title="1">{
                // create a new cache data
                as.cache[taskId] = &amp;CacheData{
                        data: []*TaskData{&amp;dataCopy},
                        ack:  0,
                }
                return
        }</span>

        // update the data in the cache
        <span class="cov8" title="1">cacheData.data = append(cacheData.data, &amp;dataCopy)</span>
}

func (as *ActivityStage) handleDataExchangeRequests() <span class="cov8" title="1">{
        // data exchange requests are received on this channel.
        //  it is shared by all tasks.

        // if a task requests data, we find the task Id, the data requirements
        // and forward the requested data to the task.
        as.wg.Add(1)

        go func() </span><span class="cov8" title="1">{
                defer as.wg.Done()

                as.OutgoingDataHandlerReady = true
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-as.ctx.Done():<span class="cov8" title="1">
                                return</span>
                        // get all pending exchange requests and try sending them out
                        case &lt;-as.newDataChan:<span class="cov8" title="1">
                                // we need a read lock
                                as.lock.RLock()
                                for _, exchangeRequest := range as.pendingExchanges </span><span class="cov8" title="1">{
                                        as.sendOutTaskData(exchangeRequest.TaskId, exchangeRequest)
                                }</span>
                                <span class="cov8" title="1">as.lock.RUnlock()</span>

                        // receive a data exchange request
                        case exchangeRequest := &lt;-as.dataExchangeChan:<span class="cov8" title="1">
                                as.lock.Lock()
                                // get associated task and check if it has outstanding data
                                if err := as.updateTaskAck(exchangeRequest.TaskId, &amp;exchangeRequest); err == nil </span><span class="cov8" title="1">{
                                        // try sending out data
                                        as.sendOutTaskData(exchangeRequest.TaskId, &amp;exchangeRequest)
                                }</span>

                                <span class="cov8" title="1">as.lock.Unlock()</span>
                        }
                }
        }()
}

func (as *ActivityStage) listTasksThatDataShouldBeSentTo(data TaskData) []uuid.UUID <span class="cov8" title="1">{
        // get the task from the graph
        edges := as.Graph.Edges[data.TaskId.String()]
        result := make([]uuid.UUID, 0)

        // get the tasks that should receive the data
        for _, edge := range edges </span><span class="cov8" title="1">{
                // convert the edge to a uuid
                uuid, err := uuid.Parse(edge)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">result = append(result, uuid)</span>
        }

        <span class="cov8" title="1">return result</span>
}

func (as *ActivityStage) getFirstTask() uuid.UUID <span class="cov8" title="1">{
        // get the first task from the graph
        topoSort, err := as.Graph.TopologicalSort()
        if err != nil </span><span class="cov0" title="0">{
                // TODO: add error to telemetry
                return uuid.Nil
        }</span>

        // return the first task
        <span class="cov8" title="1">return uuid.MustParse(topoSort[0])</span>
}

func (as *ActivityStage) updateTaskAck(taskID uuid.UUID, exchangeRequest *DataExchange) error <span class="cov8" title="1">{
        // if there is a request to flush, get the ack number and flush to that number
        // then update the ack number to 0
        taskData, exists := as.cache[taskID]

        if !exists || len(taskData.data) == 0 </span><span class="cov8" title="1">{
                as.updateExchangeRequest(exchangeRequest)
                return &amp;ActivityError{
                        Op:  "updateTaskAck",
                        Err: errors.New("no data to update ack for"),
                        Key: "no_data_to_update_ack_for",
                }
        }</span>

        // for a flush, data is flushed up to the current ack number
        // and the ack number is set to 0
        <span class="cov8" title="1">if exchangeRequest.Flush </span><span class="cov8" title="1">{
                // flash all the data up to the ack
                taskData.data = taskData.data[taskData.ack:]
                // set the taskId ack to 0
                taskData.ack = 0
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (as *ActivityStage) sendOutTaskData(taskID uuid.UUID, exchangeRequest *DataExchange) error <span class="cov8" title="1">{
        // get ack for the taskId
        taskData, exists := as.cache[taskID]
        if !exists || len(taskData.data) == 0 </span><span class="cov8" title="1">{
                return &amp;ActivityError{
                        Op:  "sendOutTaskData",
                        Err: errors.New("no data to send out"),
                        Key: "no_data_to_send_out",
                }
        }</span>

        <span class="cov8" title="1">length := len(taskData.data)
        maxDemand := taskData.ack + exchangeRequest.MaxDemand
        if maxDemand &gt; length </span><span class="cov8" title="1">{
                maxDemand = length
        }</span>

        // get the data from cache starting from the ackNumber, returning maxDemand number of data
        <span class="cov8" title="1">fetchedData := taskData.data[taskData.ack:maxDemand]

        // ensure the taskData is not less than the minDemand
        // else return
        if len(fetchedData) &lt; exchangeRequest.MinDemand </span><span class="cov8" title="1">{
                // lets wait for more data to arrive before sending them out
                // save the exchangeRequest for a future send
                as.updateExchangeRequest(exchangeRequest)
                return &amp;ActivityError{
                        Op:  "sendOutTaskData",
                        Err: errors.New("not enough data to send out"),
                        Key: "not_enough_data_to_send_out",
                }
        }</span>

        // send the data to the subscribers
        <span class="cov8" title="1">for _, data := range fetchedData </span><span class="cov8" title="1">{
                // get the data
                taskDataCopy := *data
                broadcastChan, exists := as.broadcastChan[taskID]
                if !exists </span><span class="cov0" title="0">{
                        // TODO: add error to telemetry
                        continue</span>
                }

                <span class="cov8" title="1">broadcastChan &lt;- taskDataCopy
                taskData.ack++</span>
        }

        // delete the exchange request from the list
        <span class="cov8" title="1">as.deleteExchangeRequest(exchangeRequest)
        return nil</span>
}

func (as *ActivityStage) updateExchangeRequest(exchangeRequest *DataExchange) <span class="cov8" title="1">{
        // saves the exchange request for the future.
        // this happens there is not enough data to satisfy the minimum demand requirements
        for index, ex := range as.pendingExchanges </span><span class="cov8" title="1">{
                if ex.TaskId == exchangeRequest.TaskId </span><span class="cov0" title="0">{
                        // replace the existing request
                        as.pendingExchanges[index] = exchangeRequest
                        return
                }</span>
        }

        // add the new request
        <span class="cov8" title="1">as.pendingExchanges = append(as.pendingExchanges, exchangeRequest)</span>
}

func (as *ActivityStage) deleteExchangeRequest(exchangeRequest *DataExchange) <span class="cov8" title="1">{
        for i, ex := range as.pendingExchanges </span><span class="cov8" title="1">{
                if ex.TaskId == exchangeRequest.TaskId </span><span class="cov8" title="1">{
                        as.pendingExchanges[i] = as.pendingExchanges[len(as.pendingExchanges)-1]
                        as.pendingExchanges = as.pendingExchanges[:len(as.pendingExchanges)-1]
                        break</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package activity

import (
        "fmt"

        "github.com/google/uuid"
)

// an activity is a set of one or more tasks that are executed in a specific order
// this creates a task graph

// task function type
type TaskFunc func() error

// TaskParameterDefinition defines the expected parameters
type TaskParameterDefinition struct {
        Name         string
        Type         string // e.g., "string", "int", "float", etc.
        Required     bool
        DefaultValue interface{}
        Validation   func(interface{}) error // optional validation function
}

// task data struct
type TaskData struct {
        TaskId uuid.UUID
        Error  error
        Data   interface{}
}

// task funcs struct
// TaskDefinition defines a reusable task type
type TaskDefinition struct {
        FuncId     uuid.UUID
        TaskFunc   TaskFunc
        Parameters map[string]TaskParameterDefinition // Parameter schema
}

// task struct
type Task struct {
        Id          uuid.UUID
        Name        string
        Description string
        Definition  *TaskDefinition
        Args        map[string]interface{}
}

// task interface
type TaskInterface interface {
        Add(task *Task) error
        Delete(task *Task) error
        List() []*Task
        Get(taskId uuid.UUID) (*Task, error)
        GetByName(name string) (*Task, error)
        Count() int
        ValidateTaskArgs(task *Task) error
}

// task definition interface
type TaskDefinitionInterface interface {
        Add(definition *TaskDefinition) error
        Delete(definition *TaskDefinition) error
        List() []*TaskDefinition
        Get(funcId uuid.UUID) (*TaskDefinition, error)
        GetByName(name string) (*TaskDefinition, error)
        Count() int
}

// Serializer interface for saving and loading activities
type Serializer interface {
        Save() ([]byte, error)
        Load(data []byte) error
}

// TODO: add a serializer to save the activity to file and load later
type Activity struct {
        Name        string
        Id          uuid.UUID
        Description string
        Status      string
        Tasks       []*Task
        TaskChan    chan TaskData
        Graph       *ActivityGraph
        Serializer
}

// activity interface
type ActivityInterface interface {
        Activity(name string, tasks []*Task, graph *ActivityGraph) error
}

// activity graph interface
type ActivityGraphInterface interface {
        AddNode(taskId string) error
        AddEdge(fromTaskId string, toTaskId string) error
        HasCycle() bool
        TopologicalSort() ([]string, error)
}

// activity error
type ActivityError struct {
        Op  string // the operation that caused the error
        Err error  // the original error
        Key string // related error key
}

// error interface
func (e *ActivityError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s: %s", e.Op, e.Err.Error())
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package activity

import (
        "errors"
        "sync"

        "github.com/google/uuid"
)

// TaskManager implements the TaskInterface
type TaskManager struct {
        tasks map[uuid.UUID]*Task
        mu    sync.RWMutex
}

// NewTaskManager creates a new TaskManager
func NewTaskManager() *TaskManager <span class="cov8" title="1">{
        return &amp;TaskManager{
                tasks: make(map[uuid.UUID]*Task),
        }
}</span>

// Add adds a task to the manager
func (m *TaskManager) Add(task *Task) error <span class="cov8" title="1">{
        if task == nil </span><span class="cov8" title="1">{
                return &amp;ActivityError{
                        Op:  "Add",
                        Err: errors.New("cannot add nil task"),
                }
        }</span>

        // Generate a new UUID if not provided
        <span class="cov8" title="1">if task.Id == uuid.Nil </span><span class="cov8" title="1">{
                task.Id = uuid.New()
        }</span>

        // Validate task has a definition
        <span class="cov8" title="1">if task.Definition == nil </span><span class="cov8" title="1">{
                return &amp;ActivityError{
                        Op:  "Add",
                        Err: errors.New("task must have a definition"),
                }
        }</span>

        <span class="cov8" title="1">m.mu.Lock()
        defer m.mu.Unlock()

        // Check if task with this ID already exists
        if _, exists := m.tasks[task.Id]; exists </span><span class="cov8" title="1">{
                return &amp;ActivityError{
                        Op:  "Add",
                        Err: errors.New("task with this ID already exists"),
                        Key: task.Id.String(),
                }
        }</span>

        <span class="cov8" title="1">m.tasks[task.Id] = task
        return nil</span>
}

// Delete removes a task from the manager
func (m *TaskManager) Delete(task *Task) error <span class="cov8" title="1">{
        if task == nil </span><span class="cov8" title="1">{
                return &amp;ActivityError{
                        Op:  "Delete",
                        Err: errors.New("cannot delete nil task"),
                }
        }</span>

        <span class="cov8" title="1">m.mu.Lock()
        defer m.mu.Unlock()

        if _, exists := m.tasks[task.Id]; !exists </span><span class="cov8" title="1">{
                return &amp;ActivityError{
                        Op:  "Delete",
                        Err: errors.New("task not found"),
                        Key: task.Id.String(),
                }
        }</span>

        <span class="cov8" title="1">delete(m.tasks, task.Id)
        return nil</span>
}

// List returns all tasks
func (m *TaskManager) List() []*Task <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        tasks := make([]*Task, 0, len(m.tasks))
        for _, task := range m.tasks </span><span class="cov8" title="1">{
                tasks = append(tasks, task)
        }</span>

        <span class="cov8" title="1">return tasks</span>
}

// Get retrieves a task by ID
func (m *TaskManager) Get(taskId uuid.UUID) (*Task, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        task, exists := m.tasks[taskId]
        if !exists </span><span class="cov8" title="1">{
                return nil, &amp;ActivityError{
                        Op:  "Get",
                        Err: errors.New("task not found"),
                        Key: taskId.String(),
                }
        }</span>

        <span class="cov8" title="1">return task, nil</span>
}

// GetByName retrieves a task by name
func (m *TaskManager) GetByName(name string) (*Task, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        for _, task := range m.tasks </span><span class="cov8" title="1">{
                if task.Name == name </span><span class="cov8" title="1">{
                        return task, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, &amp;ActivityError{
                Op:  "GetByName",
                Err: errors.New("task not found"),
                Key: name,
        }</span>
}

// Count returns the number of tasks
func (m *TaskManager) Count() int <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        return len(m.tasks)
}</span>

// ValidateTaskArgs validates that the task arguments match the parameter definitions
func (m *TaskManager) ValidateTaskArgs(task *Task) error <span class="cov8" title="1">{
        if task == nil </span><span class="cov8" title="1">{
                return &amp;ActivityError{
                        Op:  "ValidateTaskArgs",
                        Err: errors.New("cannot validate nil task"),
                }
        }</span>

        <span class="cov8" title="1">if task.Definition == nil </span><span class="cov8" title="1">{
                return &amp;ActivityError{
                        Op:  "ValidateTaskArgs",
                        Err: errors.New("task has no definition"),
                        Key: task.Id.String(),
                }
        }</span>

        // Check for required parameters
        <span class="cov8" title="1">for paramName, paramDef := range task.Definition.Parameters </span><span class="cov8" title="1">{
                if paramDef.Required </span><span class="cov8" title="1">{
                        if _, exists := task.Args[paramName]; !exists </span><span class="cov8" title="1">{
                                return &amp;ActivityError{
                                        Op:  "ValidateTaskArgs",
                                        Err: errors.New("missing required parameter: " + paramName),
                                        Key: task.Id.String(),
                                }
                        }</span>
                }
        }

        // Validate parameters with validation functions
        <span class="cov8" title="1">for paramName, paramValue := range task.Args </span><span class="cov8" title="1">{
                paramDef, exists := task.Definition.Parameters[paramName]
                if !exists </span><span class="cov8" title="1">{
                        return &amp;ActivityError{
                                Op:  "ValidateTaskArgs",
                                Err: errors.New("unexpected parameter: " + paramName),
                                Key: task.Id.String(),
                        }
                }</span>

                <span class="cov8" title="1">if paramDef.Validation != nil </span><span class="cov8" title="1">{
                        if err := paramDef.Validation(paramValue); err != nil </span><span class="cov8" title="1">{
                                return &amp;ActivityError{
                                        Op:  "ValidateTaskArgs",
                                        Err: errors.New("validation failed for parameter " + paramName + ": " + err.Error()),
                                        Key: task.Id.String(),
                                }
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package activity

import (
        "errors"
        "sync"

        "github.com/google/uuid"
)

// TaskDefinitionManager implements the TaskDefinitionInterface
type TaskDefinitionManager struct {
        definitions map[uuid.UUID]*TaskDefinition
        mu          sync.RWMutex
}

// NewTaskDefinitionManager creates a new TaskDefinitionManager
func NewTaskDefinitionManager() *TaskDefinitionManager <span class="cov8" title="1">{
        return &amp;TaskDefinitionManager{
                definitions: make(map[uuid.UUID]*TaskDefinition),
        }
}</span>

// Add adds a task definition to the manager
func (m *TaskDefinitionManager) Add(definition *TaskDefinition) error <span class="cov8" title="1">{
        if definition == nil </span><span class="cov8" title="1">{
                return &amp;ActivityError{
                        Op:  "Add",
                        Err: errors.New("cannot add nil task definition"),
                }
        }</span>

        // Generate a new UUID if not provided
        <span class="cov8" title="1">if definition.FuncId == uuid.Nil </span><span class="cov8" title="1">{
                definition.FuncId = uuid.New()
        }</span>

        <span class="cov8" title="1">m.mu.Lock()
        defer m.mu.Unlock()

        // Check if definition with this ID already exists
        if _, exists := m.definitions[definition.FuncId]; exists </span><span class="cov8" title="1">{
                return &amp;ActivityError{
                        Op:  "Add",
                        Err: errors.New("task definition with this ID already exists"),
                        Key: definition.FuncId.String(),
                }
        }</span>

        <span class="cov8" title="1">m.definitions[definition.FuncId] = definition
        return nil</span>
}

// Delete removes a task definition from the manager
func (m *TaskDefinitionManager) Delete(definition *TaskDefinition) error <span class="cov8" title="1">{
        if definition == nil </span><span class="cov8" title="1">{
                return &amp;ActivityError{
                        Op:  "Delete",
                        Err: errors.New("cannot delete nil task definition"),
                }
        }</span>

        <span class="cov8" title="1">m.mu.Lock()
        defer m.mu.Unlock()

        if _, exists := m.definitions[definition.FuncId]; !exists </span><span class="cov8" title="1">{
                return &amp;ActivityError{
                        Op:  "Delete",
                        Err: errors.New("task definition not found"),
                        Key: definition.FuncId.String(),
                }
        }</span>

        <span class="cov8" title="1">delete(m.definitions, definition.FuncId)
        return nil</span>
}

// List returns all task definitions
func (m *TaskDefinitionManager) List() []*TaskDefinition <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        definitions := make([]*TaskDefinition, 0, len(m.definitions))
        for _, def := range m.definitions </span><span class="cov8" title="1">{
                definitions = append(definitions, def)
        }</span>

        <span class="cov8" title="1">return definitions</span>
}

// Get retrieves a task definition by ID
func (m *TaskDefinitionManager) Get(funcId uuid.UUID) (*TaskDefinition, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        definition, exists := m.definitions[funcId]
        if !exists </span><span class="cov8" title="1">{
                return nil, &amp;ActivityError{
                        Op:  "Get",
                        Err: errors.New("task definition not found"),
                        Key: funcId.String(),
                }
        }</span>

        <span class="cov8" title="1">return definition, nil</span>
}

// GetByName retrieves a task definition by name
func (m *TaskDefinitionManager) GetByName(name string) (*TaskDefinition, error) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        for _, def := range m.definitions </span><span class="cov8" title="1">{
                for _, param := range def.Parameters </span><span class="cov8" title="1">{
                        if param.Name == name </span><span class="cov8" title="1">{
                                return def, nil
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil, &amp;ActivityError{
                Op:  "GetByName",
                Err: errors.New("task definition not found"),
                Key: name,
        }</span>
}

// Count returns the number of task definitions
func (m *TaskDefinitionManager) Count() int <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        return len(m.definitions)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
